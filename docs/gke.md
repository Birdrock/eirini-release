
# GKE with certificates generated by LetsEncrypt

- [GKE with certificates generated by LetsEncrypt](#gke-with-certificates-generated-by-letsencrypt)
  - [Prerequisites](#prerequisites)
  - [Configure Ingress](#configure-ingress)
    - [Reserve static IP address](#reserve-static-ip-address)
    - [Configure DNS](#configure-dns)
    - [Create service account with right access](#create-service-account-with-right-access)
    - [Deploy NGINX ingress controller & cert manager](#deploy-nginx-ingress-controller--cert-manager)
    - [Create a certificate issuer](#create-a-certificate-issuer)
    - [Create certificates](#create-certificates)
  - [Values.yaml](#valuesyaml)
  - [Deploying UAA](#deploying-uaa)
    - [Get UAA certificates](#get-uaa-certificates)
    - [Deploy UAA](#deploy-uaa)
  - [Deploying SCF](#deploying-scf)
    - [Get CA certificate](#get-ca-certificate)
    - [Get certificates for Gorouter](#get-certificates-for-gorouter)
    - [Deploy SCF](#deploy-scf)
  - [Certificate rotation](#certificate-rotation)
  - [Misc](#misc)

## Prerequisites

Make the Eirini helm repository available to helm:

```bash
helm repo add eirini https://cloudfoundry-incubator.github.io/eirini-release
```

Make the Bits helm repository available to helm:

```bash
helm repo add bits https://cloudfoundry-incubator.github.io/bits-service-release/helm
```

## Configure Ingress

### Reserve static IP address

See [more](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address)

### Configure DNS

Create a DNS zone in GKE.
Create the following 3 DNS records in the zone:

- `<environment>.<zone>`
- `*.<environment>.<zone>`
- `*.uaa.<environment>.<zone>`

Then attach them to the static IP address you created.

### Create service account with right access

In order to generate valid certificate your components need to be able to create TXT DNS records in your zone.
Create a service account with the following permissions:

```text
  dns.changes.create
  dns.changes.get
  dns.managedZones.list
  dns.resourceRecordSets.create
  dns.resourceRecordSets.delete
  dns.resourceRecordSets.list
  dns.resourceRecordSets.update
```

Generate a private key for it.

### Deploy NGINX ingress controller & cert manager

Deploy [Nginx ingress controller](https://hub.helm.sh/charts/stable/nginx-ingress) with the following properties:

```text
  rbac.create=true
  controller.service.loadBalancerIP=<static-ip-address>
```

Deploy [CertManager](https://hub.helm.sh/charts/jetstack/cert-manager).
The documentation below is valid only for cert-manager v0.11.

### Create a certificate issuer

Create a secret with service account key in cert-manager namespace:

```bash
kubectl create secret generic -n cert-manager <secret-name> --from-literal=service-account.json="$DNS_SERVICE_ACCOUNT"
```

This is required for DNS validation. See more
[in official documentation](https://docs.cert-manager.io/en/latest/tutorials/acme/dns-validation.html).
You can also take a look at the
[issuer that is deployed in Eirini CI environments](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/cert-manager/letsencrypt-dns-issuer.yaml).

## Values.yaml

```yaml
bits:
  env:
    DOMAIN: <domain>
  ingress:
    endpoint: <domain>
    use: true
    annotations:
      cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
      # use the following line instead if you are using regular issuer
      # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"
  secrets:
    BITS_SERVICE_SECRET: $BITS_SECRET
    BITS_SERVICE_SIGNING_USER_PASSWORD: $BITS_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

env:
    DOMAIN: <domain>

    UAA_HOST: uaa.<domain>
    UAA_PORT: 443
    UAA_PUBLIC_PORT: 443

kube:
    storage_class:
      persistent: standard
      shared: standard
    auth: rbac

secrets:
    CLUSTER_ADMIN_PASSWORD: $CLUSTER_ADMIN_PASSWORD
    UAA_ADMIN_CLIENT_SECRET: $UAA_ADMIN_CLIENT_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

ingress:
  enabled: true
  annotations:
    "nginx.ingress.kubernetes.io/proxy-body-size": "100m"
    cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
    # use the following line instead if you are using regular issuer
    # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"

eirini:
  opi:
    use_registry_ingress: true
    ingress_endpoint: $cluster_domain

  secrets:
    BLOBSTORE_PASSWORD: $BITS_SECRET
```

## Deploy UAA

```bash
  helm upgrade --install "uaa" \
    "uaa" \
    --namespace "uaa" \
    --values your-values.yaml
```

## Deploying SCF

### Get CA certificate

Some components validate the CA certificate for the UAA endpoint. You can get LetsEncrypt CA certificate for UAA running the following command:

```bash
    ROOT_CA="$(curl -s https://letsencrypt.org/certs/isrgrootx1.pem.txt)"
    INTERMEDIATE_CA="$(curl -s https://letsencrypt.org/certs/letsencryptauthorityx3.pem.txt)"
    CA_CERT="${ROOT_CA}

${INTERMEDIATE_CA}"
```

For more information about LetsEncrypt chain of trust see [here](https://letsencrypt.org/certificates/).

### Deploy SCF

```bash
  helm upgrade --install "scf" \
    cf \
    --namespace "scf" \
    --values your-values.yaml \
    --set "secrets.UAA_CA_CERT=${CA_CERT}"
```

## Certificate rotation

Bits certificate is rotated automatically by cert-manager and is picked up by Nginx Ingress controller.
Cert-manager will rotate certificates in Kubrenetes secrets, but you will have to copy them to the SCF secrets.
You can do this by upgrading UAA and SCF periodically.

## Misc

We recommend using Terraform to automate GKE cluster creation. You can check Eirini CI Terraform file [here](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/gke-cluster/terraform.tf)

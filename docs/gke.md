
# GKE with certificates generated by LetsEncrypt

- [GKE with certificates generated by LetsEncrypt](#gke-with-certificates-generated-by-letsencrypt)
  - [Prerequisites](#prerequisites)
  - [Configure Ingress](#configure-ingress)
    - [Reserve static IP address](#reserve-static-ip-address)
    - [Configure DNS](#configure-dns)
    - [Create service account with right access](#create-service-account-with-right-access)
    - [Deploy NGINX ingress controller & cert manager](#deploy-nginx-ingress-controller--cert-manager)
    - [Create a certificate issuer](#create-a-certificate-issuer)
    - [Create certificates](#create-certificates)
  - [Values.yaml](#valuesyaml)
  - [Deploying UAA](#deploying-uaa)
    - [Get UAA certificates](#get-uaa-certificates)
    - [Deploy UAA](#deploy-uaa)
  - [Deploying SCF](#deploying-scf)
    - [Get CA certificate](#get-ca-certificate)
    - [Get certificates for Gorouter](#get-certificates-for-gorouter)
    - [Deploy SCF](#deploy-scf)
  - [Certificate rotation](#certificate-rotation)
  - [Misc](#misc)

## Prerequisites

Make the Eirini helm repository available to helm:

```bash
helm repo add eirini https://cloudfoundry-incubator.github.io/eirini-release
```

Make the Bits helm repository available to helm:

```bash
helm repo add bits https://cloudfoundry-incubator.github.io/bits-service-release/helm
```

## Configure Ingress

### Reserve static IP address

See [more](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address)

### Configure DNS

Create a DNS zone in GKE.
Create the following 3 DNS records in the zone:

- <environment>.<zone>
- *.<environment>.<zone>
- *.uaa.<environment>.<zone>

Then attach them to the static IP address you created.

### Create service account with right access

In order to generate valid certificate your components need to be able to create TXT DNS records in your zone.
Create a service account with the following permissions:

```
  dns.changes.create
  dns.changes.get
  dns.managedZones.list
  dns.resourceRecordSets.create
  dns.resourceRecordSets.delete
  dns.resourceRecordSets.list
  dns.resourceRecordSets.update
```

Generate a private key for it.

### Deploy NGINX ingress controller & cert manager

Deploy [Nginx ingress controller](https://hub.helm.sh/charts/stable/nginx-ingress) with the following properties:

```
  rbac.create=true
  controller.service.loadBalancerIP=<static-ip-address>
```

Deploy [CertManager](https://hub.helm.sh/charts/jetstack/cert-manager)

### Create a certificate issuer

Create a secret with service account key in cert-manager namespace:

```
kubectl create secret generic -n cert-manager <secret-name> --from-literal=service-account.json="$DNS_SERVICE_ACCOUNT"
```

This is required for DNS validation. See more
[in official documentation](https://docs.cert-manager.io/en/latest/tutorials/acme/dns-validation.html).
You can also take a look at the
[issuer that is deployed in Eirini CI environments](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/cert-manager/letsencrypt-dns-issuer.yaml).

### Create certificates

You need to create 2 certificates:

- UAA (uaa.<domain>, *.uaa.<domain>)
- Gorouter (*.<domain>)

The certificate for the bits service will be created using cert-manager ingress annotation.
SCF works on supporting annotations as well. See [the issue](https://github.com/SUSE/scf/issues/2856)
See the reference in [Eirini CI](https://github.com/cloudfoundry-incubator/eirini-ci/tree/master/cert-manager)

## Values.yaml

```yaml
bits:
  env:
    DOMAIN: <domain>
  ingress:
    endpoint: <domain>
    use: true
    annotations:
      certmanager.k8s.io/cluster-issuer: "<lets-encrypt-issuer-name>"
      # use the following line instead if you are using regular issuer
      # certmanager.k8s.io/issuer: "<lets-encrypt-issuer-name>"
  secrets:
    BITS_SERVICE_SECRET: $BITS_SECRET
    BITS_SERVICE_SIGNING_USER_PASSWORD: $BITS_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

env:
    DOMAIN: <domain>

    UAA_HOST: uaa.<domain>
    UAA_PORT: 443
    UAA_PUBLIC_PORT: 443

kube:
    storage_class:
      persistent: standard
      shared: standard
    auth: rbac

secrets:
    CLUSTER_ADMIN_PASSWORD: $CLUSTER_ADMIN_PASSWORD
    UAA_ADMIN_CLIENT_SECRET: $UAA_ADMIN_CLIENT_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

ingress:
  enabled: true
  annotations:
    "nginx.ingress.kubernetes.io/proxy-body-size": "100m"

eirini:
  opi:
    use_registry_ingress: true
    ingress_endpoint: $cluster_domain

  secrets:
    BLOBSTORE_PASSWORD: $BITS_SECRET
```

## Deploying UAA

### Get UAA certificates

You need to wait for certificates to be issued. Then you will be able to get them from the Kubernetes secret that has been specified.

If you are using Eirini-ci templates, you can run the following command:

```bash
    UAA_TLS_CRT="$(kubectl get secret uaa-ingress --namespace cert-manager -o jsonpath="{.data['tls\.crt']}" | base64 --decode -)"
    UAA_TLS_KEY="$(kubectl get secret uaa-ingress --namespace cert-manager -o jsonpath="{.data['tls\.key']}" | base64 --decode -)"
```

### Deploy UAA

```bash
  helm upgrade --install "uaa" \
    "uaa" \
    --namespace "uaa" \
    --set "ingress.tls.crt=${UAA_TLS_CRT}" \
    --set "ingress.tls.key=${UAA_TLS_KEY}" \
    --values your-values.yaml
```

## Deploying SCF

### Get CA certificate

Some components validate the CA certificate for the UAA endpoint. You can get LetsEncrypt CA certificate for UAA running the following command:

```bash
    ROOT_CA="$(curl -s https://letsencrypt.org/certs/isrgrootx1.pem.txt)"
    INTERMEDIATE_CA="$(curl -s https://letsencrypt.org/certs/letsencryptauthorityx3.pem.txt)"
    CA_CERT="${ROOT_CA}

${INTERMEDIATE_CA}"
```

For more information about LetsEncrypt chain of trust see [here](https://letsencrypt.org/certificates/).

### Get certificates for Gorouter

You need to get certificate for Gorouter following the same procedures as [certificates for UAA](#get-uaa-certificates) for the gorouter Kubernetes secret.

If you are using eirini-ci templates, you can use the following commands:

```bash
    INGRESS_CRT="$(kubectl get secret router-ingress --namespace cert-manager -o jsonpath="{.data['tls\.crt']}" | base64 --decode -)"
    INGRESS_KEY="$(kubectl get secret router-ingress --namespace cert-manager -o jsonpath="{.data['tls\.key']}" | base64 --decode -)"
```

### Deploy SCF

```bash
  helm upgrade --install "scf" \
    cf \
    --namespace "scf" \
    --values your-values.yaml \
    --set "secrets.UAA_CA_CERT=${CA_CERT}" \
    --set "ingress.tls.crt=${INGRESS_CRT}" \
    --set "ingress.tls.key=${INGRESS_KEY}"
```

## Certificate rotation

Bits certificate is rotated automatically by cert-manager and is picked up by Nginx Ingress controller.
Cert-manager will rotate certificates in Kubrenetes secrets, but you will have to copy them to the SCF secrets.
You can do this by upgrading UAA and SCF periodically.

## Misc

We recommend using Terraform to automate GKE cluster creation. You can check Eirini CI Terraform file [here](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/gke-cluster/terraform.tf)
